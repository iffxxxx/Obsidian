## Bit Manipulation By Hand
- **한번 풀어보기:**
	![[Pasted image 20240114195846.png]]
	1. 0110 + 0110은 0110 * 2와 동등하며, 이는 0110을 왼쪽으로 1만큼 이동시키는 것과 동일합니다.
	2. 0100은 4와 동일하며, 4로 곱하는 것은 왼쪽으로 2만큼 이동하는 것과 같습니다. 그래서 0011을 왼쪽으로 2만큼 이동하여 1100을 얻습니다.
	3. 비트별로 이 작업을 생각해보세요. 비트를 그 자신의 부정값과 XOR하면 항상 1이 됩니다. 따라서 A XOR (A = NOT a)의 해는 1의 시퀀스가 됩니다.
	4. ~0은 1의 시퀀스이므로 ~0 << 2는 1로 시작하는 두 개의 0입니다. 이를 다른 값과 AND하면 값의 마지막 두 비트가 지워집니다.
## Bit Facts and Tricks
- **소개:**
	다음 표현식들은 비트 조작에서 유용합니다. 하지만 단순히 외우지 말고 각각이 왜 참인지 심도 있게 생각해보세요. "1s"와 "0s"는 각각 1의 시퀀스 또는 0의 시퀀스를 나타냅니다.
	
	![[Pasted image 20240114214729.png]]
		**^는 XOR**
	이러한 표현식을 이해하기 위해서는 이러한 연산이 비트별로 발생하며 한 비트에서 일어나는 것이 다른 비트에 영향을 미치지 않음을 기억해야 합니다. 이는 위의 각 문장이 단일 비트에 대해 참이면 비트 시퀀스에 대해서도 참임을 의미합니다.
## Two's Complement and Negative Numbers
- **개념:**
	컴퓨터는 일반적으로 정수를 2의 보수 표현으로 저장합니다. 양수는 자기 자신으로 표현되고, 음수는 그 절대값에 대한 2의 보수로 표현됩니다 (부호 비트에 음수임을 나타내기 위해 1이 들어갑니다). N비트 수 (여기서 N은 부호 비트를 제외한 숫자에 사용된 비트 수)의 2의 보수는 해당 수에 대한 $2^N$에 대한 보수입니다.
	
- **예시:**
	  ![[Pasted image 20240114215406.png]]
	4비트 정수 -3을 살펴봅시다. 이것이 4비트 숫자인 경우, 부호에는 1비트, 값에는 3비트가 할당됩니다. $2^3$에 대한 보수를 얻으려면 8을 사용합니다. -3의 절대값에 대한 8에 대한 보수는 5입니다. 5를 2진수로 나타내면 101입니다. 따라서 4비트 숫자로 표현된 -3은 1101이고, 첫 번째 비트는 부호 비트입니다.
	
	다른 말로, N비트 숫자로 표현된 -K (음수 K)의 이진 표현은 1을 제외한 (1, 2^N - 1 - K)입니다. 이를 다르게 표현하면 양수 표현의 비트를 반전하고 맨 앞에 1을 더하는 것입니다.
## Arithmetic vs. Logical Right Shift
