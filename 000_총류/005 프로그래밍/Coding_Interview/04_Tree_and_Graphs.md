#Tree 
## Introduce
- **트리 및 그래프 소개:**
	
	- 트리 및 그래프 문제는 면접에서 어렵게 여겨집니다.
	- 트리에서의 검색은 배열이나 연결 리스트와 같은 선형으로 구성된 자료 구조보다 복잡합니다.
	- 트리의 시간 복잡도는 최악 및 평균 경우에 크게 다를 수 있으며 알고리즘을 두 가지 상황에서 평가해야 합니다.
	- 트리 또는 그래프를 처음부터 구현하는 능력은 중요합니다.

## Tree
- **트리 개요:**
	
	- 트리는 노드로 이루어진 데이터 구조입니다.
	- 각 트리에는 루트 노드가 있습니다 (그래프 이론에서는 엄격히 필요하지 않지만, 프로그래밍에서는 일반적으로 사용됨).
	- 루트 노드에는 0개 이상의 자식 노드가 있습니다.
	- 각 자식 노드는 0개 이상의 자식 노드를 가질 수 있어 계층 구조를 형성합니다.
	- 트리에는 순환을 포함할 수 없습니다.
	- 노드는 특정한 순서에 있을 수도 있고 아닐 수도 있으며, 값으로는 어떤 데이터 타입이든 사용될 수 있습니다.
	- 노드는 부모 노드로의 링크가 있을 수도 있고 없을 수도 있습니다.
- **노드 클래스의 예시:**
	
	- 노드에 대한 간단한 클래스 정의가 제공되었으며, 각 노드는 이름과 자식 배열을 가지고 있습니다.
```run-python
class Node:
    def __init__(self, name):
        self.name = name
        self.children = []
```
- ### Type of Trees
	- #### Trees vs Binary Trees
		- **정의:**
			이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리입니다. 모든 트리가 이진 트리는 아닙니다. 
			  ![[Pasted image 20240111194617.png]]
			예를 들어, 다음 트리는 이진 트리가 아닙니다. 이를 삼진 트리라고 할 수 있습니다. 가끔 특정한 경우에는 이진 트리가 아닌 트리가 필요할 수 있습니다. 만약 어떤 노드가 자식이 없다면 해당 노드는 "잎 노드(leaf node)"라고 부릅니다.
			
	- #### Binary Tree vs. Binary Search Tree
		- **이진 트리 vs. 이진 탐색 트리:**
			
			- 이진 탐색 트리는 각 노드가 특정한 정렬 속성을 따르는 이진 트리입니다. 이 정렬 속성은 다음과 같습니다: 모든 왼쪽 자손은 현재 노드보다 작거나 같고, 모든 오른쪽 자손은 현재 노드보다 큽니다. 이 정렬 조건은 모든 노드에 대해 성립해야 합니다.
			  ![[Pasted image 20240111194950.png]]
			- 이 정의에서 이진 탐색 트리의 등호에 대한 정의는 약간 다를 수 있습니다. 어떤 정의에서는 트리가 중복 값을 가질 수 없습니다. 다른 정의에서는 중복 값이 오른쪽에 있거나 양쪽 어디에든 있을 수 있습니다. 이러한 모든 정의는 유효하지만, 면접관과 명확히 확인하는 것이 좋습니다.
			- 이 부등식은 해당 노드의 즉시 자식뿐만 아니라 모든 자손에 대해서 참이어야 합니다. 왼쪽에 있는 12가 8의 왼쪽에 있기 때문에 오른쪽의 트리는 이진 탐색 트리가 아닙니다.
			  
		- **이진 탐색 트리의 조건:**
			
			- 이진 탐색 트리는 각 노드에 대해 왼쪽 자손은 현재 노드보다 작거나 같아야 하고, 현재 노드는 오른쪽 자손보다 작아야 합니다.
			- 주어진 트리 문제에 대한 질문을 받았을 때, 많은 지원자들은 면접관이 이진 탐색 트리를 의미한다고 가정합니다. 하지만 꼭 확인해야 합니다. 이진 탐색 트리는 각 노드에 대해 왼쪽 자손은 현재 노드보다 작거나 같아야 하고, 현재 노드는 오른쪽 자손보다 작아야 하는 조건을 부과합니다.
	- #### Balanced vs. Unbalanced
		- **균형 잡힌 트리의 의미:**
			
			- "균형 잡힌" 트리는 실제로 "지나치게 불균형하지 않은" 것을 의미합니다. 
				  이는 삽입 및 검색에 대해 O(log n)의 시간이 소요되도록 충분히 균형이 잡혀 있지만, 꼭 최적의 균형 상태를 의미하지는 않습니다.
				  
				 균형 잡힌 트리는 높이를 최소화하여 왼쪽 서브트리와 오른쪽 서브트리의 크기 차이를 최소화합니다. 따라서 트리의 각 노드에서의 연산이 균등하게 분포됩니다.
			- "균형"이라는 용어는 왼쪽과 오른쪽 서브트리가 정확히 같은 크기를 가질 필요는 없다는 것을 의미합니다.
	- #### Complete Binary Tree
		  ![[Pasted image 20240111195600.png]]
		- 1. **각 레벨이 완전히 채워져 있음:** 트리의 모든 레벨은 가능한 최대한 완전히 채워져 있습니다. 이는 각 노드가 두 개의 자식을 가진 이진 트리의 특성을 가집니다.
	    
		- 2. **마지막 레벨은 왼쪽에서 오른쪽으로 채워짐:** 마지막 레벨이 완전히 채워져 있다면, 노드는 왼쪽에서 오른쪽으로 순서대로 채워집니다.
	- #### Full Binary Trees
		  ![[Pasted image 20240111200507.png]]
		- 1. **자식 노드의 개수가 0 또는 2개:** 트리의 모든 노드는 자식이 없거나 정확히 두 개의 자식을 가져야 합니다.
	    
		- 2. **어떤 노드도 하나의 자식만 가지지 않음:** 각 노드는 자식이 없거나 두 개의 자식을 가지므로 어떤 노드도 하나의 자식만 가질 수 없습니다.
	- #### Perfect Binary Trees
		  ![[Pasted image 20240111200732.png]]
		- 완벽한 이진 트리의 노드 수는 정확히 $2^k−1$개여야 하며, $k$는 트리의 레벨 수입니다.
- ### Binary Tree Traversal
	- **정의:**
		  이진 트리의 순회는 트리의 노드를 특정 순서로 방문하는 방법을 의미합니다. 대표적으로 중위 순회(In-Order Traversal), 전위 순회(Pre-Order Traversal), 후위 순회(Post-Order Traversal)가 있습니다.
	- #### In-Order Traversal
		- **정의:**
			- 중위 순회는 "왼쪽 서브트리 - 현재 노드 - 오른쪽 서브트리" 순서로 노드를 방문합니다.
			- 이진 탐색 트리에서 중위 순회를 수행하면 노드가 오름차순으로 정렬된 순서로 방문됩니다.
			  
		- **Code:**
			```run-python
			def in_order_traversal(node):
			    if node is not None:
			        in_order_traversal(node.left)
			        visit(node)
			        in_order_traversal(node.right)
			```
	- #### Pre-Order Traversal
		- **정의:**
			- 전위 순회는 "현재 노드 - 왼쪽 서브트리 - 오른쪽 서브트리" 순서로 노드를 방문합니다.
			- 순회를 시작하는 노드는 항상 먼저 방문됩니다.
			  
		- **Code:**
			```run-python
			def pre_order_traversal(node):
			    if node is not None:
			        visit(node)
			        pre_order_traversal(node.left)
			        pre_order_traversal(node.right)
			```
	- #### Post-Order Traversal
		- **정의:**
			- 후위 순회는 "왼쪽 서브트리 - 오른쪽 서브트리 - 현재 노드" 순서로 노드를 방문합니다.
			- 순회를 마치는 노드는 항상 마지막에 방문됩니다.
			  
		- **Code:**
			```run-python
			def post_order_traversal(node):
			    if node is not None:
			        post_order_traversal(node.left)
			        post_order_traversal(node.right)
			        visit(node)
			```
		
- ### Binary Heaps
	- #### Min-Heap
		- **정의:**
			  ![[Pasted image 20240111205239.png]]
			  Min-heap은 완전한 이진 트리(마지막 레벨의 가장 오른쪽 요소를 제외하고 모두 채워진)로, 각 노드는 자식보다 작습니다. 따라서 루트는 트리에서의 최솟값입니다.
			 
		- ##### Insert
			![[Pasted image 20240111231504.png]]
			- Min-heap에 삽입할 때는 항상 가장 아래에 요소를 삽입합니다. 완전한 트리 특성을 유지하기 위해 가장 오른쪽 자리에 삽입합니다.
			- 그런 다음 새로운 요소를 그 부모와 교체하여 요소가 올바른 위치를 찾을 때까지 트리를 "수정"합니다. 기본적으로 최솟값이 올라갑니다.
			- 이 작업은 O(log n) 시간이 소요됩니다. 여기서 n은 힙의 노드 수입니다.
		- ##### Extract Minimum Element:
			![[Pasted image 20240111231630.png]]
			- Min-heap에서 최솟값을 찾는 것은 쉽습니다: 항상 맨 위에 있습니다. 어려운 부분은 그 값을 제거하는 것입니다.
			- 먼저 최솟값을 제거하고 힙의 마지막 요소(가장 아래, 가장 오른쪽 요소)와 교체합니다.
			- 그런 다음 이 요소를 "버블 다운"하여 최소 힙 특성이 복원될 때까지 자식 중 하나와 교체합니다.
			- 왼쪽 자식과 오른쪽 자식 중 어떤 것과 교체해야 할까요? 그것은 그들의 값에 따라 달라집니다. 왼쪽과 오른쪽 요소 사이에는 본질적으로 순서가 없지만 최소 힙 순서를 유지하기 위해 더 작은 값을 선택해야 합니다.
			- 이 알고리즘 또한 O(log n) 시간이 소요됩니다.
- ### Tries (prefix Trees)
	- **정의:**
		Trie(또는 접두어 트리로 불리기도 함)는 특이한 데이터 구조입니다. 이것은 인터뷰 질문에서 자주 등장하지만 알고리즘 교재에서는 이 구조에 대해 크게 다루지 않습니다.
		![[Pasted image 20240111232018.png]]
	- **특징:**
		- Trie는 문자가 각 노드에 저장되는 n-ary tree의 변형입니다. 트리 아래로 이어진 각 경로는 단어를 나타낼 수 있습니다.
		- * 노드(때로 "null 노드"라고도 함)는 종종 완전한 단어를 나타내기 위해 사용됩니다. 예를 들어, MANY 아래에 * 노드가 있는 것은 MANY가 완전한 단어임을 나타냅니다. MA 경로의 존재는 MA로 시작하는 단어가 있음을 나타냅니다.
		- 이러한 * 노드의 실제 구현은 종종 특수한 유형의 자식(예: TerminatingTrieNode, TrieNode에서 상속)이 될 수 있습니다. 또는 "부모" 노드 내에서 사용되는 부울 플래그로 간단히 구현할 수 있습니다.
		- Trie의 노드는 1에서 ALPHABET_SIZE + 1까지의 자식을 가질 수 있습니다(또는 * 노드 대신 부울 플래그를 사용하는 경우 0에서 ALPHABET_SIZE까지).
		- Trie는 종종 전체 (영어) 언어를 빠르게 접두어 조회하기 위해 사용됩니다. 해시 테이블은 문자열이 유효한 단어인지 빠르게 확인할 수 있지만, 해당 문자열이 어떤 유효한 단어의 접두어인지 알려주지 않습니다. 이를 빠르게 수행할 수 있는 것이 Trie입니다.
	- **시간 복잡도:**
		 Trie는 문자열이 유효한 접두어인지를 확인하는 데 O(K) 시간이 걸립니다. 여기서 K는 문자열의 길이입니다. 이는 사실상 해시 테이블이 소요하는 시간과 동일합니다. 일반적으로 해시 테이블 조회를 O(1) 시간으로 언급하지만, 실제로는 입력의 모든 문자를 읽어야 하므로 O(K) 시간이 소요됩니다.
## Graph
- **트리 대 그래프:**
    
    - 트리는 그래프의 일종이지만 모든 그래프가 트리는 아닙니다. 트리는 사이클이 없는 연결된 그래프입니다.
    - 간단하게 말하면 트리는 특정한 특징을 가진 그래프의 특수한 경우입니다.
- **그래프 정의:**
    ![[Pasted image 20240111232806.png]]
    - 그래프는 일부 노드가 서로 연결된 구조입니다.
    - 그래프는 방향성이 있거나 없을 수 있습니다.
        - **방향 그래프 (유향 그래프):** 간선에 방향이 있어 일방 통행과 같습니다.
        - **무방향 그래프:** 간선에 방향이 없어 양방향 통행과 같습니다.
    - 그래프는 여러 독립적인 서브그래프로 구성될 수 있습니다.
    - 모든 정점 쌍 간에 경로가 있다면 "연결된 그래프"라고 합니다.
    - 그래프에는 사이클이 있을 수 있고 없을 수도 있습니다.
        - "비순환 그래프"는 사이클이 없는 그래프를 의미합니다.
- ### Adjacency List
	- **정의:**
		가장 흔한 그래프 표현 방법 중 하나입니다. 각 정점(또는 노드)은 인접한 정점의 목록을 저장합니다. 무방향 그래프에서 (a, b)와 같은 간선은 a의 인접한 정점 목록과 b의 인접한 정점 목록에 각각 두 번 저장됩니다.
		
		간단한 그래프 노드의 클래스 정의는 기본적으로 트리 노드와 거의 동일할 수 있습니다.
		
	- **코드:**
		```run-python
		class Graph:
		    def __init__(self, nodes):
		        self.nodes = nodes
		
		class Node:
		    def __init__(self, name, children):
		        self.name = name
		        self.children = children
		
		```
		`Graph` 클래스는 트리와 달리 하나의 노드에서 모든 노드에 도달할 수 없을 수 있기 때문에 사용됩니다. 그래프를 표현하는 데 추가적인 클래스가 필요하지 않을 수 있습니다. 인접 목록을 저장하는 배열(또는 해시 테이블)만 있으면 됩니다(배열, ArrayList, 연결 리스트 등). 위의 그래프는 다음과 같이 나타낼 수 있습니다.